{"ast":null,"code":"var __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n    d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __metadata = this && this.__metadata || function (k, v) {\n  if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\nimport { Component, inject, ChangeDetectionStrategy, HostListener } from '@angular/core';\nimport { CommonModule } from '@angular/common';\nimport { ListingsApiService } from '../listings/listings-api.service';\nimport { BehaviorSubject, combineLatest } from 'rxjs';\nimport { map, switchMap, shareReplay, distinctUntilChanged, debounceTime, catchError, startWith, tap, take } from 'rxjs/operators';\nimport { MatFormFieldModule } from '@angular/material/form-field';\nimport { MatSelectModule } from '@angular/material/select';\nimport { MatIconModule } from '@angular/material/icon';\nimport { MatCardModule } from '@angular/material/card';\nimport { ActivatedRoute, Router } from '@angular/router';\nimport { MatProgressBarModule } from '@angular/material/progress-bar';\nimport { FormsModule } from '@angular/forms';\nimport { RouterModule } from '@angular/router';\nlet SearchComponent = class SearchComponent {\n  api = inject(ListingsApiService);\n  route = inject(ActivatedRoute);\n  router = inject(Router);\n  seedingFromUrl = false;\n  hasSeeded = false;\n  // Sorting options (used in template)\n  sortOptions = [{\n    label: 'Price: Low to High',\n    value: 'price-asc'\n  }, {\n    label: 'Price: High to Low',\n    value: 'price-desc'\n  }, {\n    label: 'Year: Newest',\n    value: 'year-desc'\n  }, {\n    label: 'Year: Oldest',\n    value: 'year-asc'\n  }];\n  // Filter subjects\n  selectedMakeCodes$ = new BehaviorSubject([]);\n  selectedModelCodes$ = new BehaviorSubject([]);\n  selectedTransmissionCodes$ = new BehaviorSubject([]);\n  selectedBodyTypeCodes$ = new BehaviorSubject([]);\n  selectedFuelTypeCodes$ = new BehaviorSubject([]);\n  selectedSeats$ = new BehaviorSubject([]);\n  selectedDoors$ = new BehaviorSubject([]);\n  // Range filters\n  priceMin$ = new BehaviorSubject(undefined);\n  priceMax$ = new BehaviorSubject(undefined);\n  yearMin$ = new BehaviorSubject(undefined);\n  yearMax$ = new BehaviorSubject(undefined);\n  mileageMin$ = new BehaviorSubject(undefined);\n  mileageMax$ = new BehaviorSubject(undefined);\n  // Year dropdown options (1980..current)\n  yearStart = 1980;\n  yearEnd = new Date().getFullYear();\n  yearOptionsAsc = Array.from({\n    length: this.yearEnd - this.yearStart + 1\n  }, (_, i) => this.yearStart + i);\n  yearOptionsDesc = [...this.yearOptionsAsc].reverse();\n  // Sorting & pagination subjects\n  sort$ = new BehaviorSubject('price-asc');\n  page$ = new BehaviorSubject(1);\n  pageSize$ = new BehaviorSubject(12);\n  // Loading indicator\n  loading$ = new BehaviorSubject(true);\n  // UI state: grid/list view and mobile filters visibility\n  view$ = new BehaviorSubject('grid');\n  filtersVisible$ = new BehaviorSubject(false);\n  mobileSortOpen$ = new BehaviorSubject(false);\n  // Reference data derived from ListingService facet labels (no Catalog dependency)\n  // Facet params and counts (base stream used throughout)\n  facetParams$ = combineLatest([this.selectedMakeCodes$, this.selectedModelCodes$, this.selectedTransmissionCodes$, this.selectedBodyTypeCodes$, this.selectedFuelTypeCodes$, this.selectedSeats$, this.selectedDoors$, this.priceMin$, this.priceMax$, this.yearMin$, this.yearMax$, this.mileageMin$, this.mileageMax$]).pipe(debounceTime(100), map(([makeCodes, modelCodes, transmissionTypeCodes, bodyTypeCodes, fuelTypeCodes, seats, doors, priceMin, priceMax, yearMin, yearMax, mileageMin, mileageMax]) => ({\n    makeCodes,\n    modelCodes,\n    transmissionTypeCodes,\n    bodyTypeCodes,\n    fuelTypeCodes,\n    seats,\n    doors,\n    priceMin,\n    priceMax,\n    yearMin,\n    yearMax,\n    mileageMin,\n    mileageMax\n  })), distinctUntilChanged((a, b) => JSON.stringify(a) === JSON.stringify(b)), shareReplay(1));\n  mapFacetDto(dto) {\n    return {\n      makes: new Map(Object.entries(dto.makes).map(([k, v]) => [String(k), v])),\n      models: new Map(Object.entries(dto.models).map(([k, v]) => [String(k), v])),\n      transmissions: new Map(Object.entries(dto.transmissions).map(([k, v]) => [String(k), v])),\n      bodies: new Map(Object.entries(dto.bodies).map(([k, v]) => [String(k), v])),\n      fuels: new Map(Object.entries(dto.fuels).map(([k, v]) => [String(k), v])),\n      seats: new Map(Object.entries(dto.seats ?? {}).map(([k, v]) => [Number(k), v])),\n      doors: new Map(Object.entries(dto.doors ?? {}).map(([k, v]) => [Number(k), v])),\n      years: new Map(Object.entries(dto.years).map(([k, v]) => [Number(k), v])),\n      prices: new Map(Object.entries(dto.prices).map(([k, v]) => [Number(k), v])),\n      mileages: new Map(Object.entries(dto.mileages).map(([k, v]) => [Number(k), v])),\n      priceStep: dto.priceStep,\n      mileageStep: dto.mileageStep,\n      minMileage: dto.minMileage,\n      mileageExact: new Map(Object.entries(dto.mileageExact ?? {}).map(([k, v]) => [Number(k), v])),\n      // Labels\n      makeLabels: new Map(Object.entries(dto.makeLabels ?? {}).map(([k, v]) => [String(k), String(v)])),\n      modelLabels: new Map(Object.entries(dto.modelLabels ?? {}).map(([k, v]) => [String(k), String(v)])),\n      modelMakeCodes: new Map(Object.entries(dto.modelMakeCodes ?? {}).map(([k, v]) => [String(k), String(v)])),\n      transmissionLabels: new Map(Object.entries(dto.transmissionLabels ?? {}).map(([k, v]) => [String(k), String(v)])),\n      bodyLabels: new Map(Object.entries(dto.bodyLabels ?? {}).map(([k, v]) => [String(k), String(v)])),\n      fuelLabels: new Map(Object.entries(dto.fuelLabels ?? {}).map(([k, v]) => [String(k), String(v)]))\n    };\n  }\n  // Facet counts & labels from ListingService (single call shared)\n  facetCounts$ = this.facetParams$.pipe(switchMap(params => this.api.getFacetCounts(params)), map(dto => this.mapFacetDto(dto)), shareReplay(1));\n  // Build options arrays from label maps\n  makesAll$ = this.facetCounts$.pipe(map(fc => Array.from((fc.makeLabels ?? new Map()).entries()).map(([code, name]) => ({\n    code,\n    name\n  }))), shareReplay(1));\n  allTransmissions$ = this.facetCounts$.pipe(map(fc => Array.from((fc.transmissionLabels ?? new Map()).entries()).map(([code, name]) => ({\n    code,\n    name\n  }))), shareReplay(1));\n  allBodyTypes$ = this.facetCounts$.pipe(map(fc => Array.from((fc.bodyLabels ?? new Map()).entries()).map(([code, name]) => ({\n    code,\n    name\n  }))), shareReplay(1));\n  allFuelTypes$ = this.facetCounts$.pipe(map(fc => Array.from((fc.fuelLabels ?? new Map()).entries()).map(([code, name]) => ({\n    code,\n    name\n  }))), shareReplay(1));\n  modelsAll$ = this.facetCounts$.pipe(map(fc => {\n    const names = fc.modelLabels ?? new Map();\n    const parent = fc.modelMakeCodes ?? new Map();\n    return Array.from(names.entries()).map(([code, name]) => ({\n      code,\n      name,\n      makeCode: parent.get(code) ?? ''\n    }));\n  }), shareReplay(1));\n  // Models depend on selected make\n  models$ = combineLatest([this.modelsAll$, this.selectedMakeCodes$]).pipe(map(([all, codes]) => codes.length ? all.filter(m => codes.includes(m.makeCode)) : all), shareReplay(1));\n  // Variants filter removed\n  // Query params stream\n  query$ = combineLatest([this.selectedMakeCodes$, this.selectedModelCodes$, this.selectedTransmissionCodes$, this.selectedBodyTypeCodes$, this.selectedFuelTypeCodes$, this.selectedSeats$, this.selectedDoors$, this.priceMin$, this.priceMax$, this.yearMin$, this.yearMax$, this.mileageMin$, this.mileageMax$, this.sort$, this.page$, this.pageSize$]).pipe(debounceTime(100), map(([makeCodes, modelCodes, transmissionTypeCodes, bodyTypeCodes, fuelTypeCodes, seats, doors, priceMin, priceMax, yearMin, yearMax, mileageMin, mileageMax, sort, page, pageSize]) => ({\n    makeCodes,\n    modelCodes,\n    transmissionTypeCodes,\n    bodyTypeCodes,\n    fuelTypeCodes,\n    seats,\n    doors,\n    priceMin,\n    priceMax,\n    yearMin,\n    yearMax,\n    mileageMin,\n    mileageMax,\n    sort,\n    page,\n    pageSize\n  })), distinctUntilChanged((a, b) => JSON.stringify(a) === JSON.stringify(b)), shareReplay(1));\n  // Results stream\n  results$ = this.query$.pipe(tap(() => this.loading$.next(true)), switchMap(({\n    makeCodes,\n    modelCodes,\n    transmissionTypeCodes,\n    bodyTypeCodes,\n    fuelTypeCodes,\n    seats,\n    doors,\n    priceMin,\n    priceMax,\n    yearMin,\n    yearMax,\n    mileageMin,\n    mileageMax,\n    sort,\n    page,\n    pageSize\n  }) => {\n    const [sortBy, sortDirection] = this.mapSort(sort);\n    const params = {\n      makeCodes,\n      modelCodes,\n      transmissionTypeCodes,\n      bodyTypeCodes,\n      fuelTypeCodes,\n      seats,\n      doors,\n      priceMin,\n      priceMax,\n      yearMin,\n      yearMax,\n      mileageMin,\n      mileageMax,\n      page,\n      pageSize,\n      sortBy,\n      sortDirection\n    };\n    return this.api.searchListings(params).pipe(catchError(() => this.api.getListings({}).pipe(map(xs => ({\n      data: xs,\n      totalCount: xs.length,\n      totalPages: Math.max(1, Math.ceil(xs.length / pageSize)),\n      currentPage: page,\n      pageSize\n    })))));\n  }), tap(() => this.loading$.next(false)), shareReplay(1));\n  // Derived UI streams\n  listings$ = this.results$.pipe(map(r => r.data));\n  totalCount$ = this.results$.pipe(map(r => r.totalCount));\n  totalPages$ = this.results$.pipe(map(r => r.totalPages));\n  // Facet counts: server already computes counts ignoring each facet selection within a single response\n  // Filtered facet option streams (only show options with count > 0)\n  makes$ = combineLatest([this.makesAll$, this.facetCounts$]).pipe(map(([makes, counts]) => makes.filter(m => (counts.makes.get(m.code) ?? 0) > 0)), shareReplay(1));\n  // Show only options with count > 0 (but keep currently selected visible)\n  transmissions$ = combineLatest([this.allTransmissions$, this.facetCounts$]).pipe(map(([opts, counts]) => opts.filter(t => (counts.transmissions.get(t.code) ?? 0) > 0)), shareReplay(1));\n  bodyTypes$ = combineLatest([this.allBodyTypes$, this.facetCounts$]).pipe(map(([opts, counts]) => opts.filter(b => (counts.bodies.get(b.code) ?? 0) > 0)), shareReplay(1));\n  fuelTypes$ = combineLatest([this.allFuelTypes$, this.facetCounts$]).pipe(map(([opts, counts]) => opts.filter(f => (counts.fuels.get(f.code) ?? 0) > 0)), shareReplay(1));\n  // Seats and Doors counts already ignore their own selection in server response\n  seatsCounts$ = this.facetCounts$.pipe(map(x => x.seats));\n  doorsCounts$ = this.facetCounts$.pipe(map(x => x.doors));\n  // Options show only values with count > 0 (self-excluding counts already applied)\n  seats$ = this.seatsCounts$.pipe(map(m => {\n    const defaults = [2, 3, 4, 5, 6, 7, 8, 9];\n    const fromCounts = Array.from(m.keys());\n    return Array.from(new Set([...defaults, ...fromCounts])).sort((a, b) => a - b);\n  }), shareReplay(1));\n  doors$ = this.doorsCounts$.pipe(map(m => {\n    const defaults = [2, 3, 4, 5];\n    const fromCounts = Array.from(m.keys());\n    return Array.from(new Set([...defaults, ...fromCounts])).sort((a, b) => a - b);\n  }), shareReplay(1));\n  // Models already depend on selected make; apply counts filter too\n  filteredModels$ = combineLatest([this.models$, this.facetCounts$]).pipe(map(([models, counts]) => models.filter(m => (counts.models.get(m.code) ?? 0) > 0)), shareReplay(1));\n  // Facet collapse preferences and open states (open when any selection is active)\n  // Keep Make facet open on initial load\n  makePref$ = new BehaviorSubject(true);\n  modelPref$ = new BehaviorSubject(false);\n  transPref$ = new BehaviorSubject(false);\n  bodyPref$ = new BehaviorSubject(false);\n  fuelPref$ = new BehaviorSubject(false);\n  seatsPref$ = new BehaviorSubject(false);\n  doorsPref$ = new BehaviorSubject(false);\n  makeOpen$ = this.makePref$.asObservable();\n  modelOpen$ = this.modelPref$.asObservable();\n  transOpen$ = this.transPref$.asObservable();\n  bodyOpen$ = this.bodyPref$.asObservable();\n  fuelOpen$ = this.fuelPref$.asObservable();\n  seatsOpen$ = this.seatsPref$.asObservable();\n  doorsOpen$ = this.doorsPref$.asObservable();\n  toggleMakeFacet() {\n    this.makePref$.next(!this.makePref$.value);\n  }\n  toggleModelFacet() {\n    this.modelPref$.next(!this.modelPref$.value);\n  }\n  toggleTransmissionFacet() {\n    this.transPref$.next(!this.transPref$.value);\n  }\n  toggleBodyFacet() {\n    this.bodyPref$.next(!this.bodyPref$.value);\n  }\n  toggleFuelFacet() {\n    this.fuelPref$.next(!this.fuelPref$.value);\n  }\n  toggleSeatsFacet() {\n    this.seatsPref$.next(!this.seatsPref$.value);\n  }\n  toggleDoorsFacet() {\n    this.doorsPref$.next(!this.doorsPref$.value);\n  }\n  // Topbar controls\n  setView(v) {\n    this.view$.next(v);\n  }\n  toggleFilters() {\n    this.filtersVisible$.next(!this.filtersVisible$.value);\n  }\n  toggleMobileSort() {\n    this.mobileSortOpen$.next(!this.mobileSortOpen$.value);\n  }\n  setSort(v) {\n    this.sort$.next(v);\n    this.mobileSortOpen$.next(false);\n  }\n  // Range facet collapse preferences and open states\n  pricePref$ = new BehaviorSubject(false);\n  yearPref$ = new BehaviorSubject(false);\n  mileagePref$ = new BehaviorSubject(false);\n  priceOpen$ = combineLatest([this.priceMin$, this.priceMax$, this.pricePref$]).pipe(map(([min, max, pref]) => min != null || max != null ? true : pref), shareReplay(1));\n  yearOpen$ = combineLatest([this.yearMin$, this.yearMax$, this.yearPref$]).pipe(map(([min, max, pref]) => min != null || max != null ? true : pref), shareReplay(1));\n  mileageOpen$ = combineLatest([this.mileageMin$, this.mileageMax$, this.mileagePref$]).pipe(map(([min, max, pref]) => min != null || max != null ? true : pref), shareReplay(1));\n  togglePriceFacet() {\n    this.pricePref$.next(!this.pricePref$.value);\n  }\n  toggleYearFacet() {\n    this.yearPref$.next(!this.yearPref$.value);\n  }\n  toggleMileageFacet() {\n    this.mileagePref$.next(!this.mileagePref$.value);\n  }\n  // Facet count maps for template usage\n  makeCounts$ = this.facetCounts$.pipe(map(x => x.makes));\n  modelCounts$ = this.facetCounts$.pipe(map(x => x.models));\n  transmissionCounts$ = this.facetCounts$.pipe(map(x => x.transmissions));\n  bodyCounts$ = this.facetCounts$.pipe(map(x => x.bodies));\n  fuelCounts$ = this.facetCounts$.pipe(map(x => x.fuels));\n  // Year counts and option lists derived from server\n  yearCounts$ = this.facetCounts$.pipe(map(x => x.years));\n  yearValues$ = this.yearCounts$.pipe(map(mapper => Array.from(mapper.keys()).sort((a, b) => b - a)), shareReplay(1));\n  fromYearOptions$ = combineLatest([this.yearValues$, this.yearMax$]).pipe(map(([vals, max]) => vals.filter(y => max == null || y <= max)), shareReplay(1));\n  toYearOptions$ = combineLatest([this.yearValues$, this.yearMin$]).pipe(map(([vals, min]) => vals.filter(y => min == null || y >= min)), shareReplay(1));\n  // Year prefix sums for dynamic range counts (ascending order)\n  yearPrefixSums$ = combineLatest([this.yearCounts$, this.yearCounts$.pipe(map(m => Array.from(m.keys()).sort((a, b) => a - b)))]).pipe(map(([counts, ascYears]) => {\n    const prefix = [];\n    const index = new Map();\n    let sum = 0;\n    ascYears.forEach((y, i) => {\n      index.set(y, i);\n      sum += counts.get(y) ?? 0;\n      prefix.push(sum);\n    });\n    return {\n      sorted: ascYears,\n      prefix,\n      index\n    };\n  }), shareReplay(1));\n  // From Year counts reflect [from .. currentMax] or >= from\n  fromYearCumulativeCounts$ = combineLatest([this.yearPrefixSums$, this.yearMax$]).pipe(map(([prep, maxYear]) => {\n    const res = new Map();\n    const j = maxYear != null ? prep.index.get(maxYear) ?? -1 : -1;\n    for (let i = 0; i < prep.sorted.length; i++) {\n      const y = prep.sorted[i];\n      if (j >= 0) {\n        if (i > j) {\n          res.set(y, 0);\n          continue;\n        }\n        const left = i > 0 ? prep.prefix[i - 1] : 0;\n        const right = prep.prefix[j];\n        res.set(y, right - left);\n      } else {\n        const left = i > 0 ? prep.prefix[i - 1] : 0;\n        const total = prep.prefix[prep.prefix.length - 1] ?? 0;\n        res.set(y, total - left);\n      }\n    }\n    return res;\n  }), shareReplay(1));\n  // To Year counts reflect [currentMin .. to] or <= to\n  toYearCumulativeCounts$ = combineLatest([this.yearPrefixSums$, this.yearMin$]).pipe(map(([prep, minYear]) => {\n    const res = new Map();\n    const iMin = minYear != null ? prep.index.get(minYear) ?? -1 : -1;\n    for (let i = 0; i < prep.sorted.length; i++) {\n      const y = prep.sorted[i];\n      if (iMin >= 0) {\n        if (i < iMin) {\n          res.set(y, 0);\n          continue;\n        }\n        const left = iMin > 0 ? prep.prefix[iMin - 1] : 0;\n        const right = prep.prefix[i];\n        res.set(y, right - left);\n      } else {\n        res.set(y, prep.prefix[i]);\n      }\n    }\n    return res;\n  }), shareReplay(1));\n  // Price counts and option lists derived from server buckets\n  priceCounts$ = this.facetCounts$.pipe(map(x => x.prices));\n  priceStep$ = this.facetCounts$.pipe(map(x => x.priceStep));\n  priceValues$ = this.priceCounts$.pipe(map(mapper => Array.from(mapper.keys()).sort((a, b) => a - b)), shareReplay(1));\n  // Precompute prefix sums to support dynamic range counts\n  pricePrefixSums$ = combineLatest([this.priceCounts$, this.priceValues$]).pipe(map(([counts, vals]) => {\n    const sorted = [...vals].sort((a, b) => a - b);\n    const prefix = [];\n    const index = new Map();\n    let sum = 0;\n    sorted.forEach((start, i) => {\n      index.set(start, i);\n      sum += counts.get(start) ?? 0;\n      prefix.push(sum);\n    });\n    return {\n      sorted,\n      prefix,\n      index\n    };\n  }), shareReplay(1));\n  // For \"From\" price, show counts within [from .. currentMax] if max set, else >= from\n  fromPriceCumulativeCounts$ = combineLatest([this.pricePrefixSums$, this.priceMax$, this.priceStep$]).pipe(map(([prep, maxEnd, step]) => {\n    const res = new Map();\n    const maxStart = maxEnd != null && step ? maxEnd - (step - 1) : undefined;\n    const j = maxStart != null ? prep.index.get(maxStart) ?? -1 : -1;\n    for (let i = 0; i < prep.sorted.length; i++) {\n      const start = prep.sorted[i];\n      if (j >= 0) {\n        if (i > j) {\n          res.set(start, 0);\n          continue;\n        }\n        const left = i > 0 ? prep.prefix[i - 1] : 0;\n        const right = prep.prefix[j];\n        res.set(start, right - left);\n      } else {\n        const left = i > 0 ? prep.prefix[i - 1] : 0;\n        const total = prep.prefix[prep.prefix.length - 1] ?? 0;\n        res.set(start, total - left);\n      }\n    }\n    return res;\n  }), shareReplay(1));\n  fromPriceOptions$ = combineLatest([this.priceValues$, this.priceMax$, this.priceStep$]).pipe(map(([vals, max, step]) => vals.filter(p => max == null || p <= max)), shareReplay(1));\n  toPriceOptions$ = combineLatest([this.priceValues$, this.priceMin$, this.priceStep$]).pipe(map(([vals, min, step]) => vals.filter(p => {\n    if (min == null) return true;\n    const end = p + (step ?? 0) - 1;\n    return end >= min;\n  })), shareReplay(1));\n  // For \"To\" price, show counts within [currentMin .. to] if min set, else <= to\n  toPriceCumulativeCounts$ = combineLatest([this.pricePrefixSums$, this.priceMin$]).pipe(map(([prep, minStart]) => {\n    const res = new Map();\n    const iMin = minStart != null ? prep.index.get(minStart) ?? -1 : -1;\n    for (let i = 0; i < prep.sorted.length; i++) {\n      const start = prep.sorted[i];\n      if (iMin >= 0) {\n        if (i < iMin) {\n          res.set(start, 0);\n          continue;\n        }\n        const left = iMin > 0 ? prep.prefix[iMin - 1] : 0;\n        const right = prep.prefix[i];\n        res.set(start, right - left);\n      } else {\n        res.set(start, prep.prefix[i]);\n      }\n    }\n    return res;\n  }), shareReplay(1));\n  // Mileage counts and option lists derived from server buckets\n  mileageCounts$ = this.facetCounts$.pipe(map(x => x.mileages));\n  mileageStep$ = this.facetCounts$.pipe(map(x => x.mileageStep));\n  minMileage$ = this.facetCounts$.pipe(map(x => x.minMileage));\n  mileageExact$ = this.facetCounts$.pipe(map(x => x.mileageExact ?? new Map()));\n  mileageValues$ = this.mileageCounts$.pipe(map(mapper => Array.from(mapper.keys()).sort((a, b) => a - b)), shareReplay(1));\n  // Overall max mileage cap (max exact or bucket end)\n  maxMileageOverall$ = combineLatest([this.mileageExact$, this.mileageValues$, this.mileageStep$]).pipe(map(([exact, bucketStarts, step]) => {\n    const maxExact = Array.from(exact.keys()).reduce((mx, k) => Math.max(mx, k), 0);\n    const lastStart = bucketStarts.length ? bucketStarts[bucketStarts.length - 1] : 0;\n    const maxBucketEnd = (step ?? 0) > 0 ? lastStart + (step ?? 0) - 1 : lastStart;\n    return Math.max(maxExact, maxBucketEnd);\n  }), shareReplay(1));\n  // Mileage option sequence includes seeds, step increments, and exact mileages present\n  mileageOptionValues$ = combineLatest([this.mileageValues$, this.mileageStep$, this.mileageExact$]).pipe(map(([bucketStarts, step, exact]) => {\n    const inc = step || 5000;\n    const maxStart = bucketStarts.length ? bucketStarts[bucketStarts.length - 1] : 0;\n    const maxEnd = maxStart + inc - 1;\n    const vals = [];\n    const seed = [0, 100, 500, 1000, 2000, 3000, 4000];\n    for (const v of seed) {\n      if (v <= maxEnd) vals.push(v);\n    }\n    let cur = inc; // start at step (e.g., 5000)\n    while (cur <= maxEnd) {\n      vals.push(cur);\n      cur += inc;\n    }\n    for (const v of Array.from(exact.keys())) {\n      if (v <= maxEnd) vals.push(v);\n    }\n    return Array.from(new Set(vals)).sort((a, b) => a - b);\n  }), shareReplay(1));\n  fromMileageOptions$ = combineLatest([this.mileageOptionValues$, this.mileageMax$]).pipe(map(([vals, max]) => vals.filter(m => max == null || m <= max)), shareReplay(1));\n  // To mileage thousand-step options: start at lowest available thousand (>= minMileage), exclude 0\n  toMileageOptions$ = combineLatest([this.minMileage$, this.maxMileageOverall$]).pipe(map(([minAvail, overallMax]) => {\n    const start = Math.max(1000, Math.ceil((minAvail ?? 1) / 1000) * 1000);\n    const cap = Math.max(start, Math.ceil((overallMax ?? 0) / 1000) * 1000);\n    const arr = [];\n    for (let v = start; v <= cap; v += 1000) arr.push(v);\n    return arr;\n  }), shareReplay(1));\n  // Derive selected 'To' bucket start from max using fixed step\n  mileageMaxStart$ = combineLatest([this.mileageMax$, this.mileageStep$]).pipe(map(([end, step]) => end == null || !step ? undefined : end - (step - 1)), shareReplay(1));\n  // Mileage prefix sums for dynamic range counts\n  mileagePrefixSums$ = combineLatest([this.mileageCounts$, this.mileageValues$]).pipe(map(([counts, vals]) => {\n    const sorted = [...vals].sort((a, b) => a - b);\n    const prefix = [];\n    const index = new Map();\n    let sum = 0;\n    sorted.forEach((start, i) => {\n      index.set(start, i);\n      sum += counts.get(start) ?? 0;\n      prefix.push(sum);\n    });\n    return {\n      sorted,\n      prefix,\n      index\n    };\n  }), shareReplay(1));\n  // From Mileage counts reflect [from .. currentMax] or >= from (using bucket start for max)\n  fromMileageCumulativeCounts$ = combineLatest([this.mileagePrefixSums$, this.mileageMaxStart$]).pipe(map(([prep, maxStart]) => {\n    const res = new Map();\n    const j = maxStart != null ? prep.index.get(maxStart) ?? -1 : -1;\n    for (let i = 0; i < prep.sorted.length; i++) {\n      const m = prep.sorted[i];\n      if (j >= 0) {\n        if (i > j) {\n          res.set(m, 0);\n          continue;\n        }\n        const left = i > 0 ? prep.prefix[i - 1] : 0;\n        const right = prep.prefix[j];\n        res.set(m, right - left);\n      } else {\n        const left = i > 0 ? prep.prefix[i - 1] : 0;\n        const total = prep.prefix[prep.prefix.length - 1] ?? 0;\n        res.set(m, total - left);\n      }\n    }\n    return res;\n  }), shareReplay(1));\n  // To Mileage counts reflect [currentMin .. to] or <= to\n  toMileageCumulativeCounts$ = combineLatest([this.mileagePrefixSums$, this.mileageMin$]).pipe(map(([prep, minStart]) => {\n    const res = new Map();\n    const iMin = minStart != null ? prep.index.get(minStart) ?? -1 : -1;\n    for (let i = 0; i < prep.sorted.length; i++) {\n      const m = prep.sorted[i];\n      if (iMin >= 0) {\n        if (i < iMin) {\n          res.set(m, 0);\n          continue;\n        }\n        const left = iMin > 0 ? prep.prefix[iMin - 1] : 0;\n        const right = prep.prefix[i];\n        res.set(m, right - left);\n      } else {\n        res.set(m, prep.prefix[i]);\n      }\n    }\n    return res;\n  }), shareReplay(1));\n  // Exact mileage prefix sums for thousand-rounded counts\n  mileageExactPrefix$ = this.mileageExact$.pipe(map(exact => {\n    const sorted = Array.from(exact.keys()).sort((a, b) => a - b);\n    const prefix = [];\n    let sum = 0;\n    for (const m of sorted) {\n      sum += exact.get(m) ?? 0;\n      prefix.push(sum);\n    }\n    return {\n      sorted,\n      prefix\n    };\n  }), shareReplay(1));\n  // Total cars ignoring mileage (for 0 option on From)\n  totalMileageAll$ = this.mileageExactPrefix$.pipe(map(prep => prep.prefix[prep.prefix.length - 1] ?? 0), shareReplay(1));\n  // Display counts for From-mileage options using thousand-rounded end; override 0 => total\n  fromMileageDisplayCounts$ = combineLatest([this.mileageExactPrefix$, this.mileageMax$, this.fromMileageOptions$, this.totalMileageAll$]).pipe(map(([prep, maxSel, opts, totalAll]) => {\n    const res = new Map();\n    const sumUpTo = x => {\n      const arr = prep.sorted;\n      let lo = 0,\n        hi = arr.length - 1,\n        ans = -1;\n      while (lo <= hi) {\n        const mid = lo + hi >> 1;\n        if (arr[mid] <= x) {\n          ans = mid;\n          lo = mid + 1;\n        } else {\n          hi = mid - 1;\n        }\n      }\n      return ans >= 0 ? prep.prefix[ans] : 0;\n    };\n    const endRounded = maxSel != null ? Math.ceil(maxSel / 1000) * 1000 : prep.sorted[prep.sorted.length - 1] ?? 0;\n    for (const v of opts) {\n      const fromVal = v || 0;\n      const c = Math.max(0, sumUpTo(endRounded) - sumUpTo(fromVal - 1));\n      res.set(v, c);\n    }\n    // 0 shows all cars ignoring To\n    res.set(0, totalAll);\n    return res;\n  }), shareReplay(1));\n  toMileageDisplayCounts$ = combineLatest([this.mileageExactPrefix$, this.mileageMin$, this.toMileageOptions$]).pipe(map(([prep, min, opts]) => {\n    const res = new Map();\n    const sumUpTo = x => {\n      const arr = prep.sorted;\n      let lo = 0,\n        hi = arr.length - 1,\n        ans = -1;\n      while (lo <= hi) {\n        const mid = lo + hi >> 1;\n        if (arr[mid] <= x) {\n          ans = mid;\n          lo = mid + 1;\n        } else {\n          hi = mid - 1;\n        }\n      }\n      return ans >= 0 ? prep.prefix[ans] : 0;\n    };\n    const minLess = min != null ? sumUpTo(min - 1) : 0;\n    for (const v of opts) {\n      const endRounded = Math.ceil((v || 0) / 1000) * 1000;\n      const c = Math.max(0, sumUpTo(endRounded) - minLess);\n      res.set(v, c);\n    }\n    return res;\n  }), shareReplay(1));\n  // From mileage options filtered to those with non-zero counts (0 included)\n  fromMileageOptionsFiltered$ = combineLatest([this.fromMileageOptions$, this.fromMileageDisplayCounts$]).pipe(map(([opts, counts]) => opts.filter(o => (counts.get(o) ?? 0) > 0)), shareReplay(1));\n  toMileageOptionsFiltered$ = combineLatest([this.toMileageOptions$, this.toMileageDisplayCounts$, this.minMileage$]).pipe(map(([opts, counts, min]) => {\n    const minVal = min ?? 0;\n    return opts.filter(o => o > 0 && o >= minVal && (counts.get(o) ?? 0) > 0);\n  }), shareReplay(1));\n  // Show stepped From options where counts decrease (plus 0)\n  fromMileageOptionsStepped$ = combineLatest([this.fromMileageOptionsFiltered$, this.fromMileageDisplayCounts$]).pipe(map(([opts, counts]) => {\n    const sorted = [...opts].sort((a, b) => a - b);\n    const result = [];\n    let last = undefined;\n    for (const v of sorted) {\n      const c = counts.get(v) ?? 0;\n      if (result.length === 0) {\n        result.push(v);\n        last = c;\n        continue;\n      }\n      if (last == null || c < last) {\n        result.push(v);\n        last = c;\n      }\n    }\n    return result;\n  }), shareReplay(1));\n  fromMileageOptionsVisible$ = this.fromMileageOptionsStepped$;\n  toMileageOptionsStepped$ = combineLatest([this.toMileageOptionsFiltered$, this.toMileageDisplayCounts$]).pipe(map(([opts, counts]) => {\n    const sorted = [...opts].sort((a, b) => a - b);\n    const result = [];\n    let last = -1;\n    for (const v of sorted) {\n      const c = counts.get(v) ?? 0;\n      if (result.length === 0) {\n        result.push(v);\n        last = c;\n        continue;\n      }\n      if (c > last) {\n        result.push(v);\n        last = c;\n      }\n    }\n    return result;\n  }), shareReplay(1));\n  // Active filter chips (kind + id/value for removal)\n  activeFilterChips$ = combineLatest([this.selectedMakeCodes$, this.makes$.pipe(startWith([])), this.selectedModelCodes$, this.filteredModels$.pipe(startWith([])), this.selectedTransmissionCodes$, this.transmissions$.pipe(startWith([])), this.selectedBodyTypeCodes$, this.bodyTypes$.pipe(startWith([])), this.selectedFuelTypeCodes$, this.fuelTypes$.pipe(startWith([])), this.selectedSeats$, this.seats$.pipe(startWith([])), this.selectedDoors$, this.doors$.pipe(startWith([]))]).pipe(map(([mkCodes, makes, mdCodes, models, trCodes, transmissions, btCodes, bodies, fuCodes, fuels, seatVals, seatOpts, doorVals, doorOpts]) => {\n    const chips = [];\n    const pushNameChips = (codes, list, kind) => {\n      codes.forEach(code => {\n        const nm = list.find(x => x.code === code)?.name;\n        if (nm) chips.push({\n          kind,\n          code,\n          label: nm\n        });\n      });\n    };\n    pushNameChips(mkCodes, makes, 'make');\n    pushNameChips(mdCodes, models, 'model');\n    pushNameChips(trCodes, transmissions, 'transmission');\n    pushNameChips(btCodes, bodies, 'body');\n    pushNameChips(fuCodes, fuels, 'fuel');\n    seatVals.forEach(v => chips.push({\n      kind: 'seats',\n      value: v,\n      label: `${v} seats`\n    }));\n    doorVals.forEach(v => chips.push({\n      kind: 'doors',\n      value: v,\n      label: `${v} doors`\n    }));\n    return chips;\n  }), shareReplay(1));\n  // Count of active filters for quick display (include ranges)\n  activeFilterCount$ = combineLatest([this.activeFilterChips$, this.priceMin$, this.priceMax$, this.yearMin$, this.yearMax$, this.mileageMin$, this.mileageMax$]).pipe(map(([chips, pmin, pmax, ymin, ymax, mmin, mmax]) => {\n    let extra = 0;\n    if (pmin != null || pmax != null) extra++;\n    if (ymin != null || ymax != null) extra++;\n    if (mmin != null || mmax != null) extra++;\n    return (chips?.length ?? 0) + extra;\n  }));\n  constructor() {\n    // Enforce grid view on small screens and hide list option\n    if (typeof window !== 'undefined' && window.matchMedia) {\n      const mq = window.matchMedia('(max-width: 767px)');\n      const enforce = () => {\n        if (mq.matches && this.view$.value !== 'grid') this.view$.next('grid');\n      };\n      enforce();\n      mq.addEventListener?.('change', enforce);\n    }\n    // Seed from URL using names (comma-separated)\n    combineLatest([this.route.queryParamMap, this.makesAll$.pipe(startWith([])), this.modelsAll$.pipe(startWith([])), this.allTransmissions$.pipe(startWith([])), this.allBodyTypes$.pipe(startWith([])), this.allFuelTypes$.pipe(startWith([]))]).subscribe(([q, makes, models, transmissions, bodies, fuels]) => {\n      // Only treat the first emission as initial seeding\n      const isFirstSeed = !this.hasSeeded;\n      if (isFirstSeed) this.seedingFromUrl = true;\n      const namesToCodes = (param, list) => {\n        if (!param) return [];\n        const normalizeQuery = s => s.trim().toLowerCase().replace(/[+\\-]+/g, ' ').replace(/\\s+/g, ' ');\n        const normalizeLabel = s => (s || '').trim().toLowerCase().replace(/[\\s_\\-]+/g, ' ').replace(/\\s+/g, ' ');\n        const wanted = param.split(',').map(normalizeQuery).filter(Boolean);\n        return list.filter(x => wanted.includes(normalizeLabel(x.name ?? ''))).map(x => x.code);\n      };\n      const codesFrom = key => q.getAll(key).filter(Boolean);\n      const numbersFromCsv = param => {\n        if (!param) return [];\n        return param.split(',').map(s => Number(s.trim())).filter(n => !Number.isNaN(n));\n      };\n      // Prefer code-based params when present; fallback to names\n      const mkCodes = codesFrom('makeCodes');\n      const mdCodes = codesFrom('modelCodes');\n      const trCodes = codesFrom('transmissionTypeCodes');\n      const btCodes = codesFrom('bodyTypeCodes');\n      const fuCodes = codesFrom('fuelTypeCodes');\n      this.selectedMakeCodes$.next(mkCodes.length ? mkCodes : namesToCodes(q.get('make'), makes));\n      this.selectedModelCodes$.next(mdCodes.length ? mdCodes : namesToCodes(q.get('model'), models));\n      this.selectedTransmissionCodes$.next(trCodes.length ? trCodes : namesToCodes(q.get('trans'), transmissions));\n      this.selectedBodyTypeCodes$.next(btCodes.length ? btCodes : namesToCodes(q.get('body'), bodies));\n      this.selectedFuelTypeCodes$.next(fuCodes.length ? fuCodes : namesToCodes(q.get('fuel'), fuels));\n      // Numeric facets and ranges\n      this.selectedSeats$.next(numbersFromCsv(q.get('seats')));\n      this.selectedDoors$.next(numbersFromCsv(q.get('doors')));\n      const toNum = v => v == null || v === '' ? undefined : Number(v);\n      this.priceMin$.next(toNum(q.get('pmin')) ?? toNum(q.get('priceMin')));\n      this.priceMax$.next(toNum(q.get('pmax')) ?? toNum(q.get('priceMax')));\n      this.yearMin$.next(toNum(q.get('ymin')));\n      this.yearMax$.next(toNum(q.get('ymax')));\n      this.mileageMin$.next(toNum(q.get('mmin')) ?? toNum(q.get('mileageMin')));\n      this.mileageMax$.next(toNum(q.get('mmax')) ?? toNum(q.get('mileageMax')));\n      const s = q.get('sort');\n      if (s) this.sort$.next(s);\n      const v = (q.get('view') || '').toLowerCase();\n      if (v === 'list' || v === 'grid') this.view$.next(v);\n      const p = q.get('page');\n      this.page$.next(p ? Number(p) : 1);\n      const fv = (q.get('filters') || '').toLowerCase();\n      if (fv && (fv === '1' || fv === 'true' || fv === 'open')) this.filtersVisible$.next(true);\n      // On initial load, open facets that have selections\n      if ((this.selectedMakeCodes$.value?.length ?? 0) > 0) this.makePref$.next(true);\n      if ((this.selectedModelCodes$.value?.length ?? 0) > 0) this.modelPref$.next(true);\n      if ((this.selectedTransmissionCodes$.value?.length ?? 0) > 0) this.transPref$.next(true);\n      if ((this.selectedBodyTypeCodes$.value?.length ?? 0) > 0) this.bodyPref$.next(true);\n      if ((this.selectedFuelTypeCodes$.value?.length ?? 0) > 0) this.fuelPref$.next(true);\n      if ((this.selectedSeats$.value?.length ?? 0) > 0) this.seatsPref$.next(true);\n      if ((this.selectedDoors$.value?.length ?? 0) > 0) this.doorsPref$.next(true);\n      if (isFirstSeed) {\n        this.hasSeeded = true;\n        this.seedingFromUrl = false;\n      }\n    });\n    // Persist to URL on changes\n    combineLatest([this.selectedMakeCodes$, this.makesAll$.pipe(startWith([])), this.selectedModelCodes$, this.modelsAll$.pipe(startWith([])), this.selectedTransmissionCodes$, this.allTransmissions$.pipe(startWith([])), this.selectedBodyTypeCodes$, this.allBodyTypes$.pipe(startWith([])), this.selectedFuelTypeCodes$, this.allFuelTypes$.pipe(startWith([])), this.selectedSeats$, this.selectedDoors$, this.priceMin$, this.priceMax$, this.yearMin$, this.yearMax$, this.mileageMin$, this.mileageMax$, this.sort$, this.page$, this.filtersVisible$]).pipe(debounceTime(50)).subscribe(([mkIds, makes, mdIds, models, trIds, transmissions, btIds, bodies, fuIds, fuels, seats, doors, pmin, pmax, ymin, ymax, mmin, mmax, sort, page, filtersVisible]) => {\n      const slug = s => (s || '').toLowerCase().trim().replace(/[\\s_]+/g, '+').replace(/[+]+/g, '+');\n      const namesFor = (codes, list) => codes.map(code => list.find(x => x.code === code)?.name).filter(nm => typeof nm === 'string' && nm.length > 0).map(slug);\n      const current = this.route.snapshot.queryParamMap;\n      const useFallback = this.seedingFromUrl && !this.hasSeeded;\n      // Build params without default sort/page; append them at the end if changed\n      const qp = {\n        make: (() => {\n          const v = namesFor(mkIds, makes).join(',');\n          return v || (useFallback ? current.get('make') : undefined);\n        })(),\n        model: (() => {\n          const v = namesFor(mdIds, models).join(',');\n          return v || (useFallback ? current.get('model') : undefined);\n        })(),\n        trans: (() => {\n          const v = namesFor(trIds, transmissions).join(',');\n          return v || (useFallback ? current.get('trans') : undefined);\n        })(),\n        body: (() => {\n          const v = namesFor(btIds, bodies).join(',');\n          return v || (useFallback ? current.get('body') : undefined);\n        })(),\n        fuel: (() => {\n          const v = namesFor(fuIds, fuels).join(',');\n          return v || (useFallback ? current.get('fuel') : undefined);\n        })(),\n        seats: seats?.length ? seats.join(',') : useFallback ? current.get('seats') ?? undefined : undefined,\n        doors: doors?.length ? doors.join(',') : useFallback ? current.get('doors') ?? undefined : undefined,\n        pmin: pmin != null ? pmin : useFallback ? current.get('pmin') ?? undefined : undefined,\n        pmax: pmax != null ? pmax : useFallback ? current.get('pmax') ?? undefined : undefined,\n        ymin: ymin != null ? ymin : useFallback ? current.get('ymin') ?? undefined : undefined,\n        ymax: ymax != null ? ymax : useFallback ? current.get('ymax') ?? undefined : undefined,\n        mmin: mmin != null ? mmin : useFallback ? current.get('mmin') ?? undefined : undefined,\n        mmax: mmax != null ? mmax : useFallback ? current.get('mmax') ?? undefined : undefined\n      };\n      // Remove any code-based params so URL stays name-based\n      qp.makeCodes = null;\n      qp.modelCodes = null;\n      qp.transmissionTypeCodes = null;\n      qp.bodyTypeCodes = null;\n      qp.fuelTypeCodes = null;\n      qp.priceMin = null;\n      qp.priceMax = null;\n      qp.mileageMin = null;\n      qp.mileageMax = null;\n      // Persist view (only when not default)\n      if ((this.view$.value ?? 'grid') === 'list') qp.view = 'list';else qp.view = null;\n      // Persist filters panel visibility (best UX: only include when open)\n      qp.filters = filtersVisible ? '1' : null;\n      // Append non-default sort/page to the end\n      if (sort !== 'price-asc') qp.sort = sort;\n      if (page !== 1) qp.page = page;\n      this.router.navigate([], {\n        queryParams: qp\n      });\n    });\n    // Reset to first page when filters or sort change\n    combineLatest([this.selectedMakeCodes$, this.selectedModelCodes$, this.selectedTransmissionCodes$, this.selectedBodyTypeCodes$, this.selectedFuelTypeCodes$, this.selectedSeats$, this.selectedDoors$, this.priceMin$, this.priceMax$, this.yearMin$, this.yearMax$, this.mileageMin$, this.mileageMax$, this.sort$]).pipe(debounceTime(50)).subscribe(() => this.page$.next(1));\n    // Reset dependent selections to avoid stale combos\n    this.selectedMakeCodes$.pipe(distinctUntilChanged()).subscribe(() => {\n      if (this.seedingFromUrl) return;\n      this.selectedModelCodes$.next([]);\n    });\n    // Variant dependency removed\n  }\n  mapSort(v) {\n    switch (v) {\n      case 'price-asc':\n        return ['price', 'asc'];\n      case 'price-desc':\n        return ['price', 'desc'];\n      case 'year-asc':\n        return ['year', 'asc'];\n      case 'year-desc':\n        return ['year', 'desc'];\n      default:\n        return ['price', 'asc'];\n    }\n  }\n  prevPage() {\n    combineLatest([this.page$, this.totalPages$]).pipe(take(1)).subscribe(([p]) => {\n      if (p > 1) this.page$.next(p - 1);\n    });\n  }\n  nextPage() {\n    combineLatest([this.page$, this.totalPages$]).pipe(take(1)).subscribe(([p, t]) => {\n      if (p < t) this.page$.next(p + 1);\n    });\n  }\n  // Toggle helpers for multiselect checkboxes\n  toggle(ids$, id) {\n    const curr = ids$.value;\n    ids$.next(curr.includes(id) ? curr.filter(x => x !== id) : [...curr, id]);\n  }\n  clear(ids$) {\n    ids$.next([]);\n  }\n  removeFrom(ids$, idOrCode) {\n    ids$.next(ids$.value.filter(x => x !== idOrCode));\n  }\n  clearAll() {\n    this.selectedMakeCodes$.next([]);\n    this.selectedModelCodes$.next([]);\n    this.selectedTransmissionCodes$.next([]);\n    this.selectedBodyTypeCodes$.next([]);\n    this.selectedFuelTypeCodes$.next([]);\n    this.selectedSeats$.next([]);\n    this.selectedDoors$.next([]);\n    this.priceMin$.next(undefined);\n    this.priceMax$.next(undefined);\n    this.yearMin$.next(undefined);\n    this.yearMax$.next(undefined);\n    this.mileageMin$.next(undefined);\n    this.mileageMax$.next(undefined);\n  }\n  toggleMake(code) {\n    this.toggle(this.selectedMakeCodes$, code);\n  }\n  toggleModel(code) {\n    this.toggle(this.selectedModelCodes$, code);\n  }\n  toggleTransmission(code) {\n    this.toggle(this.selectedTransmissionCodes$, code);\n  }\n  toggleBodyType(code) {\n    this.toggle(this.selectedBodyTypeCodes$, code);\n  }\n  toggleFuelType(code) {\n    this.toggle(this.selectedFuelTypeCodes$, code);\n  }\n  toggleSeat(v) {\n    this.toggle(this.selectedSeats$, v);\n  }\n  toggleDoor(v) {\n    this.toggle(this.selectedDoors$, v);\n  }\n  // Remove a single active filter via chip close\n  removeChip(c) {\n    switch (c.kind) {\n      case 'make':\n        if (c.code != null) this.removeFrom(this.selectedMakeCodes$, c.code);\n        break;\n      case 'model':\n        if (c.code != null) this.removeFrom(this.selectedModelCodes$, c.code);\n        break;\n      case 'transmission':\n        if (c.code != null) this.removeFrom(this.selectedTransmissionCodes$, c.code);\n        break;\n      case 'body':\n        if (c.code != null) this.removeFrom(this.selectedBodyTypeCodes$, c.code);\n        break;\n      case 'fuel':\n        if (c.code != null) this.removeFrom(this.selectedFuelTypeCodes$, c.code);\n        break;\n      case 'seats':\n        if (c.value != null) this.removeFrom(this.selectedSeats$, c.value);\n        break;\n      case 'doors':\n        if (c.value != null) this.removeFrom(this.selectedDoors$, c.value);\n        break;\n    }\n  }\n  // Simple illustrative monthly price (placeholder UI affordance)\n  monthly(price) {\n    return Math.round((price || 0) / 60);\n  }\n  // Year range validation: ensure From <= To by adjusting the opposite side\n  onYearMinChange(v) {\n    const val = v === '' ? undefined : Number(v);\n    const currentMax = this.yearMax$.value;\n    this.yearMin$.next(val);\n    if (val != null && currentMax != null && val > currentMax) {\n      this.yearMax$.next(val);\n    }\n  }\n  onYearMaxChange(v) {\n    const val = v === '' ? undefined : Number(v);\n    const currentMin = this.yearMin$.value;\n    this.yearMax$.next(val);\n    if (val != null && currentMin != null && val < currentMin) {\n      this.yearMin$.next(val);\n    }\n  }\n  // Price range via bucketed selects: ensure From <= To\n  onPriceMinChange(v) {\n    const val = v === '' ? undefined : Number(v);\n    const currentMax = this.priceMax$.value;\n    this.priceMin$.next(val);\n    if (val != null && currentMax != null && val > currentMax) {\n      this.priceMax$.next(val);\n    }\n  }\n  onPriceMaxChange(v) {\n    const bucketStart = v === '' ? undefined : Number(v);\n    // Convert bucket start to bucket end using step\n    if (bucketStart == null) {\n      this.priceMax$.next(undefined);\n      return;\n    }\n    combineLatest([this.priceStep$]).pipe(take(1)).subscribe(([step]) => {\n      const end = bucketStart + (step ?? 0) - 1;\n      const currentMin = this.priceMin$.value;\n      this.priceMax$.next(end);\n      if (currentMin != null && end < currentMin) {\n        this.priceMin$.next(bucketStart);\n      }\n    });\n  }\n  // Mileage range via bucketed selects: ensure From <= To\n  onMileageMinChange(v) {\n    const val = v === '' ? undefined : Number(v);\n    const currentMax = this.mileageMax$.value;\n    this.mileageMin$.next(val);\n    if (val != null && currentMax != null && val > currentMax) {\n      this.mileageMax$.next(val);\n    }\n  }\n  onMileageMaxChange(v) {\n    const val = v === '' ? undefined : Number(v);\n    if (val == null) {\n      this.mileageMax$.next(undefined);\n      return;\n    }\n    const currentMin = this.mileageMin$.value;\n    this.mileageMax$.next(val);\n    if (currentMin != null && val < currentMin) {\n      this.mileageMin$.next(val);\n    }\n  }\n  // Keyboard shortcuts: g = grid, l = list, f = filters, esc = close panels\n  handleKeydown(ev) {\n    const tag = ev.target?.tagName?.toLowerCase();\n    if (tag === 'input' || tag === 'select' || tag === 'textarea' || ev.isComposing) return;\n    const key = ev.key?.toLowerCase();\n    if (key === 'g') {\n      this.setView('grid');\n    } else if (key === 'l') {\n      // Respect small screens: list view will be forced to grid by media enforcement\n      this.setView('list');\n    } else if (key === 'f') {\n      this.toggleFilters();\n    } else if (key === 'escape') {\n      if (this.mobileSortOpen$.value) this.mobileSortOpen$.next(false);\n      if (this.filtersVisible$.value) this.filtersVisible$.next(false);\n    }\n  }\n  // Simple per-card image carousel state (similar to Featured Listings)\n  indices = new Map();\n  currentIndex(l) {\n    return this.indices.get(l.id) ?? 0;\n  }\n  next(l) {\n    const imgs = l.images ?? [];\n    if (!imgs.length) return;\n    const i = (this.currentIndex(l) + 1) % imgs.length;\n    this.indices.set(l.id, i);\n  }\n  prev(l) {\n    const imgs = l.images ?? [];\n    if (!imgs.length) return;\n    const i = (this.currentIndex(l) - 1 + imgs.length) % imgs.length;\n    this.indices.set(l.id, i);\n  }\n};\n__decorate([HostListener('document:keydown', ['$event']), __metadata(\"design:type\", Function), __metadata(\"design:paramtypes\", [KeyboardEvent]), __metadata(\"design:returntype\", void 0)], SearchComponent.prototype, \"handleKeydown\", null);\nSearchComponent = __decorate([Component({\n  selector: 'app-search',\n  standalone: true,\n  imports: [CommonModule, FormsModule, MatFormFieldModule, MatSelectModule, MatIconModule, MatCardModule, MatProgressBarModule, RouterModule],\n  templateUrl: './search.component.html',\n  styleUrls: ['./search.component.scss'],\n  changeDetection: ChangeDetectionStrategy.OnPush\n}), __metadata(\"design:paramtypes\", [])], SearchComponent);\nexport { SearchComponent };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}